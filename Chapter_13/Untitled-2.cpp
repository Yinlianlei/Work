#include<iostream>
#include<valarray>
#include".h\Chapter_13.h"
using namespace std;
using namespace U_1;
int main(void)
{
	//私有继承
	//实现has-a关系的一种途径

    test_1 tmp("Yinlianlei",3);
    test_2 tmp2(90,143);
    Yin A(tmp,tmp2,16);
    A.show1();

    //在使用私有继承时，只能在派生类的方法中使用基类的类方法
    //若希望基类的私有类方法可以公有，则可以在派生类中的公有函数中添加一个使用基类方法的函数
    //私有继承能够使用类目和作用域运算符来调整基类的方法
    
    //对于含有返回值的基类函数，让派生类访问基类对象时可以使用强制类型转换达成
    //例：const string& test::trans() const
    //      {
    //          return (const string& ) *this;
    //      }
    //这句语句可以调用test类当作的string类对象//此处的string类为基类

    //访问基类的友元类，可以通过现实的转换为基类来调用正确的函数

    //对于使用私有继承还是包含，一般更加倾向于包含
    //1-继承可能会导致重名问题（然后虚方法可以解决一部分）
    //2-但是继承的特性比包含多，例，包含的函数在派生类可用，
    //派生类的派生类中不可用，但是在继承结构外不可用（不在继承结构之内）
    //3-但是继承可以得到派生类，因而可以访问保护成员，派生类的派生类也可以

    //需要使用私有继承的情况使需要重新定义虚函数
    //通常需要新类访问原有类的保护成员，或需要重新定义虚函数，一般需要私有函数
	return 0;
}

