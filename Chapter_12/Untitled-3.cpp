#include<iostream>
#include".h\Chapter_12.h"
using namespace std;
using namespace U_2;
int main(void)
{
	//静态联编和动态联编
    //联编：将源代码种的函数调用解释为指向特定函数代码块

    //静态联编：在编译过程种进行联编
    //动态联编：在编译器必须生成能够在程序运行时选择正确的虚方法的代码
    //即使用的是虚方法的类型而不是指针的类型

    //公有继承建立is-a关系的一种方法使如何处理指向对象的指针和引用
    //一般情况下，C++不允许将一种类型的地址赋予另一种类型的指针，也不允许一种类型的引用指向另一种类型
    //将派生类类引用或指针转换为基类引用和指针成为向上强制转换，这使公有继承不需要进行显示类型的转换
    //将基类指针或者引用转换为派生类指针或引用被称为向下强制转换//若不适用显示类型转换，则会向下强制类型转换是不允许的
    
    //隐式向上转换允许，但是隐式向下将会导致一安全问题//因而使用虚方法
    //基类
    // |
    // V
    //派生类

    test_1 A(3);
    test *B;
    B = &A;
    B->show();
    //虚方法使用的是动态联编
    //动态联编能够让程序选择特定设计的方法
    //一般默认为静态联编//由于效率和概念模型
    //概念模型
    //设计类时所需要的成员函数所需要的大概模型

    //若需要在派生类种重新定义基类的方法，则需要设置虚方法

    //虚函数工作原理：
    //对象添加隐藏成员->隐藏成员保存一个指向函数地址的数组的指针
    //若为虚函数，则虚函数表将保存新函数的地址
    //派生类定义了新函数，则会添加并保存在新的地址数组中
    //若不是虚函数则添加在旧的地址数组中
    //调用时，指针会在列表中选择相应的函数地址并调用
    
    //所以虚函数调用：
    //增大存储空间
    //增加一个额外的储存空间
    //增加额外查找地址的操作
    //以上三点使得效率变低

	//特别指出：
    //1-构造函数不可以为虚函数
    //2-析构函数必为虚函数
    //3-友元不能是虚函数，因为只有成员才能是虚函数

    //两条经验规则：
    //1-如果重新定义继承的方法，应确保和原来的原型完全相同
    //但如果返回类型是基类引用或指针，则可以修改为指向派生链的引用和指针（返回类型协变）
    class tes_1
    {
        public: 
            virtual tes_1 & show()
            {cout << 1;};
    };
    class tes_2 : public tes_1
    {
        public:
            virtual tes_2 & show()//例如此，指向了派生链的引用//如果有基类的引用指向此类的话
            {
                cout << 2;
            };
    };
    
    //2-如果基类声明被重载了，则应在派生类中重新定义所有的基类版本
    //因为如果只定义其中一个版本，其他重载将会被隐藏，使其他版本无法被使用
    //注意，若不需要修改，则新定义之调用基类版本
    //void tes_2::show(){tes_1::show();};
	return 0;
}
